&emsp;
# 图像 Images

相机加上镜头，把三维世界中的信息转换成了一个由像素组成的照片，随后存储在计算机中，作为后续处理的数据来源。

在数学中，图像可以用一个矩阵来描述；而在计算机中，它们占据一段连续的磁盘或内存空间，可以用二维数组来表示。这样一来，程序就不必区别它们处理的是一个数值矩阵，还是有实际意义的图像了。

本节，我们将介绍计算机图像处理的一些基本操作。

特别地，通过 OpenCV 中图像数据的处理，理解计算机中处理图像的常见步骤，为后续章节打下基础。

&emsp;
## 2.1 计算机中图像的表示
我们从最简单的图像——灰度图开始说起。在一张灰度图中，每个像素位置 (x, y) 对应到一个灰度值 $I$，所以一张宽度为 $w$，高度为 $h$ 的图像，数学形式可以记成一个矩阵：

$$\pmb{I}(x，y) \in \mathbb{R}^{w\times h}$$

然而，计算机并不能表达整个实数空间，所以我们只能在某个范围内，对图像进行量化。例如常见的灰度图中，我们用 $0-255$ 之间整数（即一个 `unsigned char`，一个字节）来表达图像的灰度大小。那么，一张宽度为 $640$，高度为 $480$ 分辨率的灰图度就可以这样表示：

```c++
unsigned char image[480][640]
```

为什么这里的二维数组是 480 × 640 呢？因为在程序中，图像以一个二维数组形式存储。它的第一个下标则是指数组的行，而第二个下标是列。在图像中，数组的行数对应图像的高度，而列数对应图像的宽度。

下面我们来考察这个图像的内容。图像自然是由像素组成的。当我们访问某一个像素时，需要指明它所处的坐标，请看图 5-8 。 图 5-8 左边显示了传统像素坐标系的定义方式。一个像素坐标系原点位于图像的左上角，X 轴向右，Y 轴向下（也就是前面所说的 u, v 坐标）。如果它还有第三个轴的话，根据右手法则，Z 轴应该是向前的。这种定义方式是与相机坐标系一致的。我们平时说的图像的宽度和列数，对应着 X 轴；而图像的行数或高度，则对应着它的 Y 轴。

<div align="center">
    <image src="./imgs/5.2-1.png" width = 600>
</div>
&emsp;


根据这种定义方式，如果我们讨论一个位于 x, y 处的像素，那么它在程序中的访问方式应该是：

```c++
unsigned char pixel = image[y][x];
```

它对应着灰度值 $I(x, y)$ 的读数。请注意这里的 x 和 y 的顺序。虽然我们有些繁琐地向读者讨论坐标系的问题，但是像这种下标顺序的错误，会是新手在调试过程中经常碰到的，又具有一定隐蔽性的错误之一。如果你在写程序时不慎调换了 x, y 的坐标，编译器无法提供任何信息，而你能看到的只是程序运行中的一个越界错误而已。

&emsp;
>距离信息
- 一个灰度像素可以用八位整数记录，也就是一个 0-255 之间的值。当我们要记录的信息更多时，一个字节恐怕就不够了。

    例如，在 RGB-D 相机的深度图中，记录了各个像素离相机的距离。这个距离通常是 `毫米` 为单位，而 RGB-D 相机的量程通常在十几米范围左右，超过了 255 的最大值范围。这时，人们会采用十六位整数（C++ 中的 unsigned short）来记录一个深度图的信息，也就是位于 0 至 65536 之间的值。换算成毫米的话，最大可以表示 65 米，足够一个 RGB-D 相机使用了。

&emsp;
>色彩信息
- 彩色图像的表示则需要通道（channel）的概念。在计算机中，我们用红色，绿色和蓝色这三种颜色的组合来表达任意一种色彩。

    于是对于每一个像素，就要记录它的 R,G,B 三个数值，每一个数值就称为一个通道。
    
    例如，最常见的彩色图像有三个通道，每个通道都由 8 位整数表示。在这种规定下，一个像素占据了 24 位空间。
    
    通道的数量，顺序都是可以自由定义的。在 OpenCV 的彩色图像中，通道的默认顺序是 B,G,R。也就是说，当我们得到一个 24 位的像素时，前 8 位表示蓝色数值，中间 8 位为绿色，最后 8 位为红色。同理，亦可使用 R,G,B 的顺序表示一个彩色图。如果我们还想表达图像的透明度时，就使用 R,G,B,A 四个通道来表示它。


